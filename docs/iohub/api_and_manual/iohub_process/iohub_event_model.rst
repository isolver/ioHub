######################
The ioHub Event Model
######################

To use the ioHub Event Monitoring Framnework effectively, is can be useful to understand
the ioHub event model, including the life cycle of an ioHub event, how to 
access ioHub events in different ways, and why you want want to do so, 
and how and when to clear events that are buffered on in iohub Process


ioHub Event Buffers
###################### 

The ioHub Process buffers events received from monitored devices so that they are available
to the PsychoPy process, when the PsychoPy process wants them. ioHub Event Buffers
are always implemented as circular buffers (using the Python collections.deque class).

Regardless of how many events are received by the ioHub Process and what the 
PsychoPy Process does with them (if anything), the ioHub Process itself will only
ever grow to a fixed maximum size in memory, based on the maximum size specified 
for the different event buffers.

There are two levels of event buffers in the ioHub Process:

* Device Event Buffers accessed using the the PsychoPy's Process's ioHubDeviceView getEvents() method; one buffer is created per device specified for use by the experiment. The maximum size of a Device Event buffer is determined by the value of the 'event_buffer_length' configuration property of the device. These buffers store events generated by the device in question, and when accessed are returned sorted by time, oldest event first.
* Global Event Buffer, accessed using the ioHubConnection's getEvents() method, stored events received from all devices being monitored. There is only one Global Event Buffer in the ioHub Process, holding up a mximum number of events as specified by the 'global_event_buffer' prefernce setting. The Global Event Buffer also returns events sorted by time. Sorting this is done as each event is added to the buffer so that when it is time to send the events to the PsychoPy Process, it does not have to sort a bunch of events all at once.

Device Event Buffer's are intended for use when it is desired to get access only
a specific device instance's events.

The Global Event Buffer is useful in cases where you need to scan through all
the different device event types regardless of the Device type that generated it.

There may be cases where your experiment can take advantage of both levels of 
event buffers within the experiment, and the experiment logic that is using 
one or more device level buffers will likely not want to effect the state of 
the global event buffer as those events are needed by a different part of the
experiment logic, and visa versa.  An example of such a case could be when it
is desired to save events from all monitored devices in a custom event file format
instead of using the DataStore, while also using event data to control the experiment
'states'. The Global Event Buffer could be used for saving events, while the 
Device Event Buffers are being used for experiment flow control. When the experiment
gets Events from a device's event buffer, the Global Event Buffer is not affected, 
and  vice versa .

ioHub DeviceEvent Life Cycle
##############################

A 'native device event' is the event as received by the ioHub Process from the underlying 
device interface being used to monitor a device for events. The life cyle of an ioHub 
DeviceEvent starts when a native device event is received, and ends when the 
ioHub DeviceEvent that was created to represent the native event is either:

* Sent to the PsychoPy Process.
* Cleared from the ioHub Process by the PsychoPy Process.
* Removed from the ioHub Process because the buffer holding the event has become full is has removed the event so a newer event can be added.

The main operations that occur with each event within this process are:

* The event is time stamped using the shared ioHub / PsychoPy time base when it has been time stamped by the source native device.
* When an event does have a natively provided time stamp, it is converted to the shared ioHub / PsychoPy time base. 
* If possible, the time base conversion process corrects the time created ioHub time for the event by facting in any delay or drift between the device's native time base and the ioHub time.
* The native event is converted into the accociated ioHub DeviceEvent format.
* The ioHub DeviceEvent is then added to:

    * Added to the ioHub's Global Event Buffer.
    * Added to the Device Buffer's based on the event's Parent Device.
    * Handed to the ioHub DataStore for persistant storage if the DataStore is being used. 

Working with ioHub DeviceEvents
################################

Using a Device Event Buffer
============================

If the reaction time between when a screen was first shown and when the spacebar 
key is pressed needs to be calulated, while also keeping the PsychoPy window updated::

    # Assumes 'io' object was created using the 
    # iohub.launchHubProcess() function and
    # 'window' is a full screen PsychoPy Window

    # save some 'dots' during the trial loop
    keyboard = io.devices.keyboard

    # Store the RT calculation here
    spacebar_rt=0.0

    # build visual stim as needed
    # ....

    # Display first frame of screen
    flip_time=window.flip()

    io.clearEvents('all')

    # Run each trial until space bar is pressed
    while spacebar_rt == 0.0:
        events=keyboard.getEvents()
   
        for kb_event in events:
            if kb_event.key == ' ':
                spacebar_rt=kb_event.time-flip_time

        # Update visual stim as needed
        # ....
    
        # Display next frame of screen
        window.flip()

The above code is desirable since:

* No events that occured prior to the initial display of the stimuli will be received. 
* Only keyboard events are needed so only keyboard events are received.
* Events are received sorted by time, so the first ' ' key event encountered will be the KeyPress event; no need to check the event type.
* The reaction time calculation is based on when the stimulus was first shown to the time of the key press event, not the time the event was handled by PsychoPy.

Using the Global Event Buffer
==============================

Assume Mouse movement events need to be used by an experiment, but only between
the time when the key 's' was pressed until the first time key 'e' is pressed by the 
participant. The Global Event Buffer can be used to do this as follows, while 
also keeping the PsychoPy window in an updated state::

    # Assumes 'io' object was created using the 
    # iohub.launchHubProcess() function and
    # 'window' is a full screen PsychoPy Window

    # store the 's' key event and 'e' key events in these objects.
    s_event=None
    e_event=None

    # build visual stim as needed
    # ....
    flip_time=window.flip()

    io.clearEvents('all')

    while you_want_to_run_the_trial:
        events=io.getEvents()
   
        while s_event is None and events:
            event = events.pop(0)
            if event.type == EventConstants.KEYBOARD_KEY and event.key == 's':
                s_event=event
        
        while events and s_event and not e_event:
            event = events.pop(0)
            if event.type == EventConstants.MOUSE_MOVE:
                # do as you will with the mouse event....
                # i.e.
                time_since_s_pressed=event.time-s_event.time                    
            
            elif event.type == EventConstants.KEYBOARD_KEY and event.key == 'e':
                e_event=event

        # build visual stim as needed
        # ....
        flip_time=window.flip()
                    
The above code is desirable since:

* Mouse motion events can simply be selected based on whether the 's' key and 'e' key event have been encountered; no need to compare event time.
* No mouse movement events will be skipped betwen the 's' key event and 'e' key event, or when a screen update is being done.
* If a time difference calculation is desired, it can be done based on the event time attribue, not based on when the event was received by the PsychoPy process.
