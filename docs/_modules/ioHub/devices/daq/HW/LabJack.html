
<!DOCTYPE html>


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>ioHub.devices.daq.HW.LabJack &mdash; ioHub 0.6rc1 documentation</title>
    
    <link rel="stylesheet" href="../../../../../_static/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/css/bootstrap-2.2.1.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/css/bootstrap-responsive-2.2.1.min.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '0.6rc1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/..\..\Python-2.7.3\Lib\site-packages\IPython\frontend\html\notebook\static\mathjax"></script>
    <script type="text/javascript" src="../../../../../_static/js/bootstrap-2.2.1.min.js"></script>
    <script type="text/javascript" src="../../../../../_static/bootstrap-sphinx.js"></script>
    <link rel="top" title="ioHub 0.6rc1 documentation" href="../../../../../index.html" />
    <link rel="up" title="ioHub.devices.daq" href="../../daq.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>
<div class="container">
  
  <div id="navbar" class="navbar navbar-fixed-top">
    <div class="navbar-inner">
      <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
      <button class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>

      <a class="brand" href="../../../../../index.html">ioHub</a>
      <span class="navbar-text pull-left"><b>0.6rc1</b></span>

      <div class="nav-collapse">
        <ul class="nav">
          <li class="divider-vertical"></li>
          
            <li class="dropdown">
  <a href="../../../../../index.html" class="dropdown-toggle" data-toggle="dropdown">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"><ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/quickstart.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/api/api_home.html">API Specification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/api/indices.html">6. API Index</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/performance.html">Performance Considerations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/known_issues.html">Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/change_log.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/credits.html">Credits</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../../iohub/iohub_license.html">License</a></li>
</ul>
</ul>
</li>
            <li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"></ul>
</li>
          
          
            
          
          
            <li></li>
          
        </ul>

        
          
<form class="navbar-search pull-right" style="margin-bottom:-3px;" action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        
      </div>
    </div>
  </div>

  
  <h1>Source code for ioHub.devices.daq.HW.LabJack</h1><pre>
import ioHub
from ...import DAQDevice, DAMultiChannelInputEvent#, DASingleChannelInputEvent
from ....import Computer, EventConstants, DeviceConstants, ioDeviceError
import pylabjack
import numpy as N

<div class="viewcode-block" id="DAQ"><a class="viewcode-back" href="../../../../../iohub/api/device_details/daq_interface/LabJack_Implementation_Notes.html#ioHub.devices.daq.HW.LabJack.DAQ">[docs]</a>class DAQ(DAQDevice):
    """
    """
    NUM_CHANNELS=8
    CHANNEL_NUMBERS = range(NUM_CHANNELS)
    CHANNEL_OPTIONS = [0, 0, 0, 0, 0, 0, 0, 0]
    DAQ_CHANNEL_MAPPING = dict()
    DAQ_CHANNEL_MAPPING['AIN0'] = 0
    DAQ_CHANNEL_MAPPING['AIN1'] = 1
    DAQ_CHANNEL_MAPPING['AIN2'] = 2
    DAQ_CHANNEL_MAPPING['AIN3'] = 3
    DAQ_CHANNEL_MAPPING['AIN4'] = 4
    DAQ_CHANNEL_MAPPING['AIN5'] = 5
    DAQ_CHANNEL_MAPPING['AIN6'] = 6
    DAQ_CHANNEL_MAPPING['AIN7'] = 7


    DAQ_CONFIG_OPTIONS = dict()
    DAQ_CONFIG_OPTIONS['DEFAULTOPTION'] = 0

    DAQ_MODEL_OPTIONS = dict()
    DAQ_MODEL_OPTIONS['U6'] = 'U6'

    ANALOG_TO_DIGITAL_RANGE=2**16
    ANALOG_RANGE=22.0
    ALL_EVENT_CLASSES = []
    # &lt;&lt;&lt;&lt;&lt;
    lastPollTime = 0.0

    # &gt;&gt;&gt; implementation specific private class attributes
    _DLL = None
    # &lt;&lt;&lt;

    DEVICE_MODEL_ID=2
    DEVICE_TYPE_ID = DeviceConstants.DAQ
    DEVICE_TYPE_STRING = DeviceConstants.getName(DEVICE_TYPE_ID)

    _newDataTypes = [('board_id', N.uint8), ('daq_model',N.str_,32), ('resolution_index',N.uint8), ('settling_factor',N.uint8),
                     ('channel_sample_rate', N.uint16)]

    __slots__=[e[0] for e in _newDataTypes]+['_device','_scanBuffer','_sampleCount','_missedCount','_lastStartStreamingTimePre','_lastStartStreamingTimePost','_streaming','_feedbackArguments']
    def __init__(self, *args, **kwargs):
        """
        """
        deviceConfig = kwargs['dconfig']

        self._startupConfiguration = deviceConfig

        DAQ.ALL_EVENT_CLASSES = [DAMultiChannelInputEvent, ]

        deviceConfig['name'] = deviceConfig.get('name', 'daq')
        deviceConfig['device_class'] = DAQ.__name__
        deviceConfig['monitor_event_types'] = deviceConfig.get('monitor_event_types', DAQ.ALL_EVENT_CLASSES)
        deviceConfig['max_event_buffer_length'] = deviceConfig.get('event_buffer_length', 1024)
        deviceConfig['type_id'] = self.DEVICE_TYPE_ID
        deviceConfig['_isReportingEvents'] = deviceConfig.get('auto_report_events', False)
        deviceConfig['os_device_code'] = 'OS_DEV_CODE_NOT_SET'

        deviceConfig['board_id'] = deviceConfig.get('board_id', 0)
        deviceConfig['daq_model']=deviceConfig.get('daq_model','U6')
        deviceConfig['resolution_index'] = deviceConfig.get('resolution_index', 0)
        deviceConfig['settling_factor'] = deviceConfig.get('settling_factor', 0)
        deviceConfig['channel_sample_rate']=deviceConfig.get('channel_sample_rate',1000)

        DAQDevice.__init__(self, *args, **deviceConfig)

        self._device=None

        if self.daq_model == 'U6':
            from pylabjack import u6 # Import the u6 class
            self._device = u6.U6()
            self._device.getCalibrationData()

        self._lastStartStreamingTimePre=0.0
        self._lastStartStreamingTimePost=0.0
        self._missedCount=0
        self._scanBuffer=[0] * self.NUM_CHANNELS
        self._streaming=False




<div class="viewcode-block" id="DAQ.enableEventReporting"><a class="viewcode-back" href="../../../../../iohub/api/device_details/daq_interface/LabJack_Implementation_Notes.html#ioHub.devices.daq.HW.LabJack.DAQ.enableEventReporting">[docs]</a>    def enableEventReporting(self, enable):
        try:
            #ioHub.print2err("---------------------------------------------")
            #ioHub.print2err("DAQ.enableEventReporting: ", enable)
            current = self.isReportingEvents()
            if enable is False and current == enable:
                return current
            if enable is True and current is True and self._streaming is True:
                return True

            if DAQDevice.enableEventReporting(self, enable) is True:
                #ioHub.print2err("enabling streaming....")

                self._missedCount=0
                self._sampleCount=0
                self._lastStartStreamingTimePre = 0.0
                self._lastStartStreamingTimePost = 0.0
                self._scanBuffer=[0]*self.NUM_CHANNELS

                #self._lastStartStreamingTimePre=Computer.getTime()
                #self._device.streamConfig(NumChannels=self.NUM_CHANNELS, ChannelNumbers=self.CHANNEL_NUMBERS,
                #    ChannelOptions=self.CHANNEL_OPTIONS, SettlingFactor=self.settling_factor,
                #    ResolutionIndex=self.resolution_index, ScanFrequency=self.channel_sample_rate)
                FIOEIOAnalog = ( 2 ** self.NUM_CHANNELS ) - 1;
                fios = FIOEIOAnalog &amp; (0xFF)
                eios = FIOEIOAnalog/256

                from pylabjack import u6
                self._device.getFeedback(u6.PortDirWrite(Direction = [0, 0, 0], WriteMask = [0, 0, 15]))


                self._feedbackArguments = []

                self._feedbackArguments.append(u6.DAC0_8(Value = 125))
                self._feedbackArguments.append(u6.PortStateRead())

                gain_index=0
                differential=False
                for i in range(self.NUM_CHANNELS):
                    self._feedbackArguments.append( u6.AIN24(i,self.resolution_index, gain_index, self.settling_factor, differential) )

                #ioHub.print2err(self.NUM_CHANNELS, "ChannelNumbers=",self.CHANNEL_NUMBERS,
                #    "ChannelOptions=",self.CHANNEL_OPTIONS, "SettlingFactor=",self.settling_factor,
                #    "ResolutionIndex=",self.resolution_index, "ScanFrequency=",self.channel_sample_rate)

                #self._lastStartStreamingTimePost=Computer.getTime()

                if self._streaming is False:
                    #self._device.streamStart()
                    self._streaming=True
                    #ioHub.print2err("Streaming started...")

            else:
                #ioHub.print2err("disabling streaming....")
                if self._streaming is True:
                    self._streaming=False
                    #self._device.streamStop()
            #ioHub.print2err("---------------------------------------------")
        except:
            ioHub.printExceptionDetailsToStdErr()
</div>
    def _poll(self):
        try:
            pollTime=Computer.currentSec()
            rend=pollTime
            if self.isReportingEvents() is True and self._streaming is True:
                rstart=Computer.currentTime()
                results = self._device.getFeedback(self._feedbackArguments )
                rend=Computer.currentTime()
                ci=rend-rstart
                event =[
                
                    0, # exp id
                    0, # session id
                    Computer._getNextEventID(), # event id
                    DAMultiChannelInputEvent.EVENT_TYPE_ID, # event type
                    0, # device time
                    pollTime, # logged time
                    rend, # hub time
                    ci, # confidence interval
                    rend-self._lastPollTime, # delay
                    0, # filter_id
                    self.DEVICE_MODEL_ID
                    ]
                for j in range(self.NUM_CHANNELS):
                    ain = self._device.binaryToCalibratedAnalogVoltage(0, results[ 2 + j ])
                    event.append(ain)
                self._addNativeEventToBuffer(event)
        except:
            ioHub.printExceptionDetailsToStdErr()
        self._lastPollTime=rend
        return True

                #self._device.nextStreamData(convert=False)


#                if ljData is not None:
#                    dataReadTime=Computer.currentSec()
#
#                    if ljData['errors'] != 0:
#                        print "Error: %s ; " % ljData['errors'], Computer.getTime()
#
#                    if ljData['numPackets'] != self._device.packetsPerRequest:
#                        print "----- UNDERFLOW : %s : " % ljData['numPackets'], ()
#
#                    if ljData['missed'] != 0:
#                        self._missedCount += ljData['missed']
#                        print "+++ Missed ", ljData['missed']
#
#                    receivedSamples=[]
#                    eventSamples=[]
#                    analogChannelName='AIN{0}'
#                    minSampleLength=100000000
#                    for k in xrange(8):
#                        channelName=analogChannelName.format(k)
#                        nSamples=len(ljData[channelName])
#                        if  nSamples&lt;minSampleLength:
#                            minSampleLength=nSamples
#                        receivedSamples.append(ljData[channelName])
#
#                    # put extra samples in buffer for use in next scan
#                    for k in xrange(8):
#                        eventSamples.append(self._scanBuffer[k])
#                        eventSamples[k].extend(receivedSamples[k][:minSampleLength])
#                        self._scanBuffer[k]=receivedSamples[k][minSampleLength:]
#                        #print "CHANNEL {0}: EVENT LENGTH: {1}".format(k,len(eventSamples[k]))
#
#                    # createEvents
#                    events=[]
#                    nsamples=len(eventSamples[0])
#                    for si in xrange(nsamples):
#                        time = (1000.0/self.channel_sample_rate)*self._sampleCount+self._lastStartStreamingTimePost
#                        self._sampleCount+=1
#                        event =[
#                            0, # exp id
#                            0, # session id
#                            Computer._getNextEventID(), # event id
#                            DAMultiChannelInputEvent.EVENT_TYPE_ID, # event type
#                            0, # device time
#                            pollTime, # logged time
#                            time, # hub time
#                            self._lastStartStreamingTimePost - self._lastStartStreamingTimePre, # confidence interval
#                            dataReadTime - time, # delay
#                            0 # filter_id
#                            ]
#                        for k in xrange(8):
#                            event.append(eventSamples[k][si])
#
#
#                        self._addNativeEventToBuffer(event)
#        except:
#            ioHub.printExceptionDetailsToStdErr()
#        pollCompetedTime=Computer.currentSec()
#        return True

    def _getIOHubEventObject(self,event):
        return event # already a Gamepad Event




    def _close(self):
        #self._device.streamStop()
        self._device.close()


    def __del__(self):
        try:
            self._close()
        except:
            pass</pre></div>

</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2013, iSolver Software Solutions.<br/>
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.<br/>
    </p>
  </div>
</footer>
  </body>
</html>